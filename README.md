<h2>Инструкция запуска и описание проекта</h2>
<hr>

Данный проект это небольшое fullstack app, которое включает как browser часть с UI, так и API. API может быть частино использован через browser, но POST запросы только через CURL/Postman. Я покажу запуск через CURL. Также данный проект был "containerized" через `Docker` (image). Покажу как запустить данный app в одном из пунктов (см. table of contents)

``` bash
1. Общая структура приложения
2. Browser/UI состовляющая
3. API часть
4. БД и краткое описание Flask Migrate
5. Использование CURL для отправки запросов + о API (browser & CURL)
6. Unit Testing
7. Запуск (про **docker pull** и общие шаги)
8. Tree проекта
```

1. Общая структура приложения

- Во-первых, все необходимые модули могут быть найдены в `requirements.txt`. Введите следующую команду для запуска: `pip install -r requirements.txt`.

- Далее, в архитектурном плане я использовал Application Factory, так как это позволяет быстро менять конфигурации нашего проекта. Например, для development одна, а для production - другая. (см файл `config.py`)

- В качестве базы данных я использовал встроенную SQLite, однако, также я использовал flask migrations, чтобы иметь доступ к разным версиям бд при необходимости. Подробную установку покажу в соответствующем пункте

<h3>Важно!</h3>

- Для того, чтобы отслеживать изменения в бд (структура), я использую `flask migrations`. Однако, с данным приложением есть небольшие сложности в использовании. Поэтому, для простоты я поместил `db.create_all()` в `routes.py` & `api_routes.py` в `.before_app_first_request` => если приложение запускается впервые (когда еще нет `urls.db` в `main`), то данный метод создаст БД и все должно быть окей.

2. Browser/UI состовляющая

- При открытии `'/'` мы увидим 2 незвисимые формы: первая позволяет ввести длинный URL и получить короткий, а вторая позволяет ввести короткий URL и получить соответствующий длинный. Они независимы и так называемый `submit` для каждой свой. В качестве `forms` я решил использовать не стандартные `html`, а `wtf`, так как с ними удобнее. `.strip()` позволяет убрать spaces до и после (если таковые имеются). Также если отправить пустоту в форме `long to short`, то выпадет сообщение о необходимости ввести хоть что-то. 

- Различные `edge cases` постарался учесть. Во-первых, если вводится длинный URL, уже существующий в бд, то произойдет перенаправление на другой route с сообщением о данной проблеме. Также, если вводимый короткий URL не существует в бд, то также произойдет перенаправление с сообщением.

- Если все ОК, то variables будут помещены в `sessions` для дальнейшего доступа. Произойдет перенаправление в соотвутствующие helper functions, где `edge cases` по отсутствию variables в session также применил. Данные helper functions выдадут результат в browser.

- В качетсве визуализации я использовал jinja2 templates и bootstrap с буквально крупицой css от меня. Файл home_page.html будет нашим основным файлом, который будет "расширяться" парой других.

- <ins>(данное применимо и для API часть)</ins> route `/info` позволяет посмотреть все существующие данные в бд, **sorted by** <ins>times_visited</ins>

<h3>Важно!</h3>

<h5>(данное применимо и для API часть)</h5>

- Как создается short url? При создании элемента в бд, в `__init__` будет
активированан метод, который при использовании библиотеки `string` сделает уникальный url из [a-zA-Z0-9]. Если созданный url уже в бд, то будет использована recursion, чтобы найти уникальный. А для того, чтобы в окне  браузера придать short url правильный вид, используем url_for. Далее мы можем использовать ссылку. Метод `get_short_ver` деалет `redirect` нашего короткого url и позволяет видеть 
ту же страницу, что и с длинным url. Однако, для удобства мы будем хранить в бд только 5 characters нашего уникального url (5 я выбрал специально, можно поменять на другое число).

- Если user введет несуществующую страницу, то в результате он получит `custom error page`. Это сделано через отдельный Blueprint и `html` page. 


3. API часть

- API позволяет получить результат как через browser, так и через CLI. Однако, в browser мы можем делать только GET request. 

- "Инициализация" происходит как отдельный `Blueprint`. Для отличия с обычным route я добавил `/api`: url_prefix='/api' + здесь мы можем указать версию API, если такое необходимо: /api/v1.

- в `api_routes` можно найти все routes. Я сделал 2 способа отправки url: через http body и через query string. Основным является первый вариант, который находится выше. Второй вариант я подписал и поместил ниже. Все `edge cases` с `browser` часть повторяются здесь и пару допольнительных также написал.


4. БД и краткое описание Flask Migrate
 
SQLite использована как основная бд в моем приложении. Однако, я сделал одну бд для "production" и отдельную для "testing". Пример структуры БД привел ниже:


```bash
id | long_url    | short_url | times_visited | link_created

1    https://vdd     cJa54         2         	Sat, 10 Jul 2021 19:08:39 GMT
2    http://wrb      8sL9C         4         	Sun, 11 Jul 2021 12:08:39 GMT 

```

`unqiue` в long_url & short_url позволяют не иметь повторений в БД.

- serialize метод используется в API части проекта для возврата данных в JSON формате.

<h4>Про flask migrate</h4>

Подробое описание делал для своего другого проекта. Описание можно найти здесь: [Ссылка](https://github.com/SleeplessChallenger/Flask_blog/blob/main/Flask_memos/Flask_Migrate.md)
<br>
Здесь кратко опишу шаги. В данном случае, если скачать мой проект, то доп действий делать не нужно (**даже если удалить бд**), однако,
во избежании поломок я распишу как установить в проект migrations.

Заходим в папку `main` через `cd main`. 

А) Если бд еще нет
	- export FLASK_APP=__init__.py
	- flask db migrate
	- flask db upgrade

Б) Если бд уже создана

	- export FLASK_APP=__init__.py
	- flask db init
	- SQLALCHEMY_DATABASE_URI=sqlite:/// flask db migrate
	- flask db stamp head

В) Если все равно какие-то ошибки:
	- удалеяем файл migration вместе с бд
	- проделываем все из пункта А


5. Использование CURL для отправки запросов + о API (browser & CURL)

- в browser по своей сути мы можем делать только GET запросы (в моем случае только использовать `/info` route). Все остальные методы - POST
методы. Про разницу между http body и query string писал выше. Здесь хотел бы показать CURL команды, которые можно использовать для работы с проектом:

Данный long url уже существует и при `api/long` выдаст json() response о том, что такой url уже есть и парой других комментариев. <br>

`curl -X POST -H "Content-Type: application/json" -d '{"url": "https://www.joneslanglasalle.co.jp/en"}' http://0.0.0.0:7000/api/long`

Команда ниже вернет длинный URL, так как короткий URL ниже уже есть в БД: <br>
`curl -X POST -H "Content-Type: application/json" -d '{"url": "https://KUb39"}' http://0.0.0.0:7000/api/short`

Пример, когда URL идут в качестве query string: <br>
`curl -X POST http://0.0.0.0:7000/api/shortQuery?url=LVp5r`, `curl -X POST http://0.0.0.0:7000/api/longQuery?url=https://gist.github.com/subfuzion`

6. Unit Testing

В папке `tests` можно найти тесты к данному приложению. Ниже я кратко опишу каждый из файлов.

- `test_basic.py` проверяет работу приложения в общем. Ничего необыччного.
- `test_model.py` проверяет различные методы нашей БД: `__repr__`, `serialize()`  и т.д.
- `test_routes.py` тестриует все методы с GET/POST request, как методы реагирует на ошибки. Также тестируем `session`.
- `test_api.py` также протестирует все методы нашего API с GET/POST request + тестируются как методы, где данные в http body, так и когда данные передаются в query string. 

+ в процессе тестов я использую `mock.patch`, чтобы имитировать некоторые методы.

7. Запуск

Есть 2 способа запуска приложения: скачать проект с GitHub и скачать с `docker hub` и запущено на локальной машине. Далее я опишу шаги для второй возможности, так как первый способ лишь потребует запуска след. команды: `python3 run.py`.

<h5>Docker launch</h5>

	1. Для того, чтобы забрать Image на локальную машину, вводим следующую команду: `docker pull enoshima/url_shortener:latest`

	2. Далее нам необходимо сделать контейнер на локальной машине на базе скачанного `image`.
	Для этого берем за основу следующую команду: `docker run --name cont -d -p 7000:7000 node_dir:latest`. Меняем имя/порты/image под соответствующие и запускаем. Например, `docker run --name url_app -d -p 7000:7000 enoshima/url_shortener:latest`

	3. После этого мы можем использовать весь функционал. 

8. Tree проекта
``` bash
.
├── Dockerfile
├── README.md
├── docker-compose.yml
├── main
│   ├── __init__.py
│   ├── api
│   │   ├── __init__.py
│   │   ├── api_routes.py
│   │   └── utils.py
│   ├── config.py
│   ├── errors
│   │   ├── __init__.py
│   │   └── handlers.py
│   ├── forms.py
│   ├── migrations
│   │   ├── README
│   │   ├── alembic.ini
│   │   ├── env.py
│   │   ├── script.py.mako
│   │   └── versions
│   │       └── f229ac2f4187_.py
│   ├── models.py
│   ├── routes.py
│   ├── static
│   │   └── main.css
│   ├── templates
│   │   ├── errors
│   │   │   └── 404.html
│   │   ├── home_page.html
│   │   ├── info_urls.html
│   │   ├── longToshort_urls.html
│   │   ├── shortTolong_urls.html
│   │   └── two_forms.html
│   ├── test_urlDB.db
│   └── urls.db
├── requirements.txt
├── run.py
└── tests
    ├── __init__.py
    ├── test_api.py
    ├── test_basic.py
    ├── test_model.py
    └── test_routes.py
```
